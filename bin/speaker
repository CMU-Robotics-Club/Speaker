#!/usr/bin/env python

import argparse
import logging
import time
import sys
import subprocess
import re
import os
import multiprocessing
import signal

from daemonize import Daemonize
import psutil
import pafy

from rc.clients import APIClient


logger = None

def _work(value):
    """
    Provided a channel value, first
    searches for espeak command line
    arguments.  Next, searches for youtube
    urls and if it finds them plays them through
    VLC.  Lastly, espeak is called.
    Blocks at each call to VLC and espeak.
    """

    tokens = value.split()

    # Supported espeak arguments 
    arguments = ['-a', '-l', '-p', '-s', '-v']

    args = []

    for argument in arguments:
        # argument in value
        if argument in tokens:
            # Index of argmue value
            i = tokens.index(argument) + 1
 
            # argument value
            v = tokens[i]
 
            tokens.remove(argument)
            tokens.remove(v)

            args.append(argument)
            args.append(v)

    # Search for youtube urls
    for token in tokens:
        try:
            video = pafy.new(token)
        except:
            # Not a youtube url
            continue

        # Play audio
        bestaudio = video.getbestaudio()
        url = bestaudio.url
        tokens.remove(token)
        subprocess.call(["cvlc", token])
 

    # Uses the remaining tokens for espeak
    s = " ".join(tokens)
    args = ['espeak'] + args + [s]
    subprocess.call(args)


def main():
    """
    Worker function for the daemon.
    Checks for an update on the speak channel
    and if there is a change before launching
    a new process to handle it, kill all current
    child processs stopping any currently running
    espeak or VLC processs started from previous values.
    """

    client = APIClient()

    # Get ID of speak channel
    channel_id = client.channels(name='speak')[0]['id']

    logger.info("Speak channel ID {}".format(channel_id))

    logger.info("starting main loop")

    # Initial channel query
    message = client.channel(channel_id)

    while True:
        logger.debug("beginning of loop iteration")

        # Ignore network errors and try again
        try:
            new_message = client.channel(channel_id)
        except Exception as e:
            pass

        # Care about 'value' or 'updated' field 
        if message['value'] != new_message['value'] or message['updated'] != new_message['updated']:
            value = new_message['value']

            # If new message kill existing children
            # from previous value(s)
            p = psutil.Process(os.getpid())
            child_pids = p.get_children(recursive=True)

            for child_pid in child_pids:
                child_pid.send_signal(signal.SIGKILL)

            # Start new process
            process = multiprocessing.Process(target=_work, args=(value,))
            process.start()

            message = new_message

        time.sleep(3)


if __name__ == '__main__':
    pid = "/tmp/speakertron.pid"

    parser = argparse.ArgumentParser()
    parser.add_argument('action', choices=["start", "stop"], help="Action for the daemon to take")
    parser.add_argument('-l', '--logfile', help="Log to the specified file")

    args = parser.parse_args()

    action = args.action
    logfile = args.logfile

    logger = logging.getLogger()

    keep_fds = []

    # Setup logging
    if logfile:
        logger.setLevel(logging.DEBUG)

        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

        # 2 1MB log files
        file_handler = logging.handlers.RotatingFileHandler(logfile, maxBytes=1024*1024, backupCount=2)
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
        
        keep_fds.append(file_handler.stream.fileno())


    # Setup daemon
    daemon = Daemonize(app="speakertron", pid=pid, action=main, logger=logger, keep_fds=keep_fds)

    if action == "start":
        daemon.start()
    elif action == "stop":
        os.system("kill -9 `cat {}`".format(pid))
        daemon.exit()
